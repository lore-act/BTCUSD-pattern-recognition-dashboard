<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>BTC/USD Dashboard</title>
    <link rel="stylesheet" href="btc_dashboard_style.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  </head>
  <body>
    <h1>BTC/USD Live Dashboard (MA crossing)</h1>

    <canvas id="btcChart" width="1400" height="500"></canvas>
    <div id="decision">Loading...</div>

    <div id="MostSimilarPattern" style="margin-top: 80px">
      <h2>Most Similar Pattern Visualization (Period: 5)</h2>
      <canvas id="SimilarPattern" width="1400" height="300"></canvas>
      <div
        id="patternSummary"
        style="color: #ccc; font-size: 16px; margin-top: 10px"
      ></div>
    </div>

    <div id="diffChartContainer" style="margin-top: 40px">
      <h2>Max-Min Difference (Period: 5)</h2>
      <canvas id="diffChart" width="1400" height="300"></canvas>
    </div>

    <script>
      let chart, diffChart, patternChart;

      function calculateMovingAverage(data, period) {
        let movingAverage = [];
        for (let i = 0; i < data.length; i++) {
          if (i >= period - 1) {
            let sum = 0;
            for (let j = i - period + 1; j <= i; j++) sum += data[j];
            movingAverage.push(sum / period);
          } else movingAverage.push(null);
        }
        return movingAverage;
      }

      function calculateMaxMinDiff(data, period) {
        let maxMin = [];
        for (let i = 0; i < data.length; i++) {
          if (i >= period - 1) {
            let min = Infinity,
              max = -Infinity;
            for (let j = i - period + 1; j <= i; j++) {
              if (data[j] < min) min = data[j];
              if (data[j] > max) max = data[j];
            }
            maxMin.push(max - min);
          } else maxMin.push(null);
        }
        return maxMin;
      }

      function checkIdx(arr, idx) {
        if (idx <= 0 || arr[idx] === null || arr[idx - 1] === null)
          return false;
        return arr[idx] > arr[idx - 1];
      }

      async function updateDashboard() {
        const decisionEl = document.getElementById("decision");
        const summaryEl = document.getElementById("patternSummary");

        // Fetch live Binance data
        const res = await fetch(
          "https://api.binance.com/api/v3/klines?symbol=BTCUSDT&interval=1m&limit=50"
        );
        const data = await res.json();
        const times = data.map((c) => new Date(c[0]).toLocaleTimeString());
        const onlyClosePrices = data.map((c) => parseFloat(c[4]));
        const ma5 = calculateMovingAverage(onlyClosePrices, 5);
        const ma30 = calculateMovingAverage(onlyClosePrices, 30);
        const diff5 = calculateMaxMinDiff(onlyClosePrices, 5);

        const lastIndex = onlyClosePrices.length - 1;
        const ma5GoingUp = checkIdx(ma5, lastIndex);
        const ma30GoingUp = checkIdx(ma30, lastIndex);
        const liveTrend =
          ma5GoingUp && ma30GoingUp
            ? "bullish"
            : !ma5GoingUp && !ma30GoingUp
            ? "bearish"
            : "neutral";

        // Fetch pattern JSON once
        let predictedTrend = "pattern not found";
        let decision = "HOLD";
        let patternData = null;

        try {
          const resPattern = await fetch("mostSimilar.json");
          if (resPattern.ok) patternData = await resPattern.json();
        } catch (err) {
          console.warn("Failed to load mostSimilar.json:", err);
        }

        if (patternData && patternData.futurePattern?.length > 0) {
          predictedTrend = patternData.direction || "pattern not found";
          if (liveTrend === "bullish" && predictedTrend === "bullish")
            decision = "BUY";
          else if (liveTrend === "bearish" && predictedTrend === "bearish")
            decision = "SELL";
        }

        // Update decision display
        decisionEl.innerText = `Decision: ${decision} | Live: ${liveTrend}, Predicted: ${predictedTrend}`;

        // Update BTC Chart
        const datasets = [
          {
            label: "Close Price",
            data: onlyClosePrices,
            borderColor: "yellow",
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
          },
          {
            label: "MA 5",
            data: ma5,
            borderColor: "cyan",
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
          },
          {
            label: "MA 30",
            data: ma30,
            borderColor: "magenta",
            borderWidth: 2,
            pointRadius: 0,
            fill: false,
          },
        ];
        const ctx = document.getElementById("btcChart").getContext("2d");
        if (chart) chart.destroy();
        chart = new Chart(ctx, {
          type: "line",
          data: { labels: times, datasets },
          options: {
            responsive: false,
            interaction: { mode: "index", intersect: false },
            scales: {
              x: { ticks: { color: "#aaa" } },
              y: { ticks: { color: "#aaa" } },
            },
            plugins: { legend: { labels: { color: "#eee" } } },
          },
        });

        // Update Max-Min Diff Chart
        const diffClean = diff5.map((v) => (v === null ? 0 : v));
        const diffCtx = document.getElementById("diffChart").getContext("2d");
        if (diffChart) diffChart.destroy();
        diffChart = new Chart(diffCtx, {
          type: "bar",
          data: {
            labels: times,
            datasets: [
              {
                label: "Max-Min absolute Diff (Period 5)",
                data: diffClean,
                backgroundColor: "orange",
              },
            ],
          },
          options: {
            responsive: false,
            scales: {
              x: { ticks: { color: "#aaa" } },
              y: { ticks: { color: "#aaa" } },
            },
            plugins: { legend: { labels: { color: "#eee" } } },
          },
        });

        // Update Most Similar Pattern Visualization
        if (
          !patternData ||
          !Array.isArray(patternData.futurePattern) ||
          patternData.similarCount === 0
        ) {
          summaryEl.innerHTML = "No valid similar pattern found.";
          if (patternChart) {
            patternChart.destroy();
            patternChart = null;
          }
        } else {
          const {
            futurePattern,
            historicalPattern,
            direction,
            mse,
            similarCount,
          } = patternData;
          summaryEl.innerHTML = `Found ${similarCount} similar patterns.<br>Most similar pattern direction: <strong>${predictedTrend}</strong><br>MSE: <strong>${mse.toFixed(
            8
          )}</strong>`;

          if (patternChart) patternChart.destroy();
          const patternCanvas = document.getElementById("SimilarPattern");
          const patternCtx = patternCanvas.getContext("2d");
          patternCtx.clearRect(0, 0, patternCanvas.width, patternCanvas.height);
          const fullPattern = [...historicalPattern, ...futurePattern];
          const labels = fullPattern.map((_, i) =>
            i < historicalPattern.length
              ? `-${historicalPattern.length - i}m`
              : `+${i - historicalPattern.length + 1}m`
          );
          patternChart = new Chart(patternCtx, {
            type: "line",
            data: {
              labels,
              datasets: [
                {
                  label: `Pattern | MSE: ${mse.toFixed(4)}`,
                  data: fullPattern,
                  borderWidth: 2,
                  fill: false,
                  pointRadius: 0,
                  borderColor: "blue",
                  segment: {
                    borderColor: (ctx) =>
                      ctx.p0DataIndex < historicalPattern.length
                        ? "blue"
                        : direction === "bullish"
                        ? "green"
                        : "red",
                  },
                },
              ],
            },
            options: {
              responsive: false,
              scales: {
                x: { ticks: { color: "#aaa" } },
                y: { ticks: { color: "#aaa" } },
              },
              plugins: { legend: { labels: { color: "#eee" } } },
            },
          });
        }
      }

      // Run immediately and every 30s
      updateDashboard();
      setInterval(updateDashboard, 30000);
    </script>
  </body>
</html>
